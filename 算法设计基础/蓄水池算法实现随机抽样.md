<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Reservoir Sampling](#reservoir-sampling)
  - [1.é¢˜ç›®æè¿°](#1%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0)
  - [2.ç®—æ³•æè¿°](#2%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0)
  - [3.ç®—æ³•æ¨å¯¼](#3%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC)
  - [4.Code](#4code)
  - [5.ç®—æ³•é™åˆ¶](#5%E7%AE%97%E6%B3%95%E9%99%90%E5%88%B6)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Reservoir Sampling

### 1.é¢˜ç›®æè¿°

ç°åœ¨æœ‰ä¸€ç»„æ•°ï¼Œä¸çŸ¥é“è¿™ç»„æ•°çš„æ€»é‡æœ‰å¤šå°‘ï¼Œè¯·æè¿°ä¸€ç§ç®—æ³•èƒ½å¤Ÿåœ¨è¿™ç»„æ•°æ®ä¸­éšæœºæŠ½å–kä¸ªæ•°ï¼Œä½¿å¾—æ¯ä¸ªæ•°è¢«å–å‡ºæ¥çš„æ¦‚ç‡ç›¸ç­‰ã€‚

å¦‚æœè¿™ç»„æ•°æœ‰nä¸ªï¼Œé‚£ä¹ˆæ¯ä¸ªæ•°å­—å–åˆ°çš„æ¦‚ç‡å°±æ˜¯k/nï¼Œä½†æ˜¯è¿™ä¸ªé—®é¢˜çš„éš¾ç‚¹åœ¨äºä¸çŸ¥é“è¿™ç»„æ•°çš„æ€»æ•°ï¼Œä¹Ÿå°±æ˜¯ä¸çŸ¥é“nï¼Œé‚£ä¹ˆè¯¥æ€ä¹ˆè®¡ç®—æ¯ä¸ªæ•°å–åˆ°çš„æ¦‚ç‡å‘¢ï¼Ÿ

è“„æ°´æ± ç®—æ³•çš„å…³é”®åœ¨äºä¿è¯æµå…¥è“„æ°´æ± çš„æ°´å’Œå·²ç»åœ¨æ± ä¸­çš„æ°´ä»¥ç›¸åŒçš„æ¦‚ç‡ç•™å­˜åœ¨è“„æ°´æ± ä¸­ï¼Œå¹¶ä¸”è“„æ°´æ± ç®—æ³•å¯ä»¥åœ¨ä¸é¢„å…ˆçŸ¥é“æ€»é‡çš„æƒ…å†µä¸‹ï¼Œåœ¨æ—¶é—´å¤æ‚åº¦O(N)çš„æƒ…å†µä¸‹ï¼Œæ¥è§£å†³è¿™ç±»é‡‡æ ·é—®é¢˜ã€‚

### 2.ç®—æ³•æè¿°

å‡è®¾æ•°æ®åºåˆ—çš„è§„æ¨¡ä¸º $n$ï¼Œéœ€è¦é‡‡æ ·çš„æ•°é‡çš„ä¸º ğ‘˜ã€‚

é¦–å…ˆæ„å»ºä¸€ä¸ªå¯å®¹çº³ ğ‘˜ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œå°†åºåˆ—çš„å‰ ğ‘˜ä¸ªå…ƒç´ æ”¾å…¥æ•°ç»„ä¸­ã€‚

ç„¶åä»ç¬¬ ğ‘˜+1ä¸ªå…ƒç´ å¼€å§‹ï¼Œä»¥ $\frac{k}{n}$ çš„æ¦‚ç‡æ¥å†³å®šè¯¥å…ƒç´ æ˜¯å¦è¢«æ›¿æ¢åˆ°æ•°ç»„ä¸­ï¼ˆæ•°ç»„ä¸­çš„å…ƒç´ è¢«æ›¿æ¢çš„æ¦‚ç‡æ˜¯ç›¸åŒçš„ï¼‰ã€‚ å½“éå†å®Œæ‰€æœ‰å…ƒç´ ä¹‹åï¼Œæ•°ç»„ä¸­å‰©ä¸‹çš„å…ƒç´ å³ä¸ºæ‰€éœ€é‡‡å–çš„æ ·æœ¬ã€‚

ä¼ªä»£ç æè¿°ï¼š

```ä¼ªä»£ç 
array R[k];    // result
integer i, j;

// fill the reservoir array
for each i in 1 to k do
    R[i] := S[i]
done;

// replace elements with gradually decreasing probability
for each i in k+1 to length(S) do
    j := random(1, i);   // important: inclusive range
    if j <= k then
        R[j] := S[i]
    fi
done
```



### 3.ç®—æ³•æ¨å¯¼

å¯¹äºç¬¬ ğ‘– ä¸ªæ•°ï¼ˆğ‘–â‰¤ğ‘˜ï¼‰ã€‚åœ¨ ğ‘˜æ­¥ä¹‹å‰ï¼Œè¢«é€‰ä¸­çš„æ¦‚ç‡ä¸º 1ã€‚

å½“èµ°åˆ°ç¬¬ ğ‘˜+1æ­¥æ—¶ï¼Œè¢« ğ‘˜+1ä¸ªå…ƒç´ æ›¿æ¢çš„æ¦‚ç‡= $k+1$ ä¸ªå…ƒç´ è¢«é€‰ä¸­çš„æ¦‚ç‡* $i$ è¢«é€‰ä¸­æ›¿æ¢çš„æ¦‚ç‡ï¼Œå³ä¸º 
$$
\frac{k}{k+1} \times \frac{1}{k}=\frac{1}{k+1}
$$
åˆ™è¢«ä¿ç•™çš„æ¦‚ç‡ä¸º
$$
1-\frac{1}{k+1}=\frac{k}{k+1}
$$
ä¾æ¬¡ç±»æ¨ï¼Œä¸è¢« ğ‘˜+2 ä¸ªå…ƒç´ æ›¿æ¢çš„æ¦‚ç‡ä¸º $1-\frac{k}{k+2} \times \frac{1}{k}=\frac{k+1}{k+2}$ã€‚åˆ™è¿è¡Œåˆ°ç¬¬ ğ‘›æ­¥æ—¶ï¼Œè¢«ä¿ç•™çš„æ¦‚ç‡ = è¢«é€‰ä¸­çš„æ¦‚ç‡ * ä¸è¢«æ›¿æ¢çš„æ¦‚ç‡ï¼Œå³ï¼š
$$
1 \times \frac{k}{k+1} \times \frac{k+1}{k+2} \times \frac{k+2}{k+3} \times \ldots \times \frac{n-1}{n}=\frac{k}{n}
$$
å¯¹äºç¬¬ ğ‘—ä¸ªæ•°ï¼ˆğ‘—>ğ‘˜ï¼‰ã€‚åœ¨ç¬¬ ğ‘— æ­¥è¢«é€‰ä¸­çš„æ¦‚ç‡ä¸º ğ‘˜ğ‘—ã€‚ä¸è¢« ğ‘—+1ä¸ªå…ƒç´ æ›¿æ¢çš„æ¦‚ç‡ä¸º 
$$
1-\frac{k}{j+1} \times \frac{1}{k}=\frac{j}{j+1}
$$
åˆ™è¿è¡Œåˆ°ç¬¬ ğ‘› æ­¥æ—¶ï¼Œè¢«ä¿ç•™çš„æ¦‚ç‡ = è¢«é€‰ä¸­çš„æ¦‚ç‡ * ä¸è¢«æ›¿æ¢çš„æ¦‚ç‡ï¼Œå³ï¼š
$$
\frac{k}{j} \times \frac{j}{j+1} \times \frac{j+1}{j+2} \times \frac{j+2}{j+3} \times \ldots \times \frac{n-1}{n}=\frac{k}{n}
$$
æ‰€ä»¥å¯¹äºå…¶ä¸­æ¯ä¸ªå…ƒç´ ï¼Œè¢«ä¿ç•™çš„æ¦‚ç‡éƒ½ä¸º$\frac{k}{n}$

### 4.Code

```c++
#include <iostream>
#include <string>
#include <vector>
#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <ctime>
using namespace std;

/** 
 * Reservoir Sampling Algorithm
 * 
 * Description: Randomly choose k elements from n elements ( n usually is large
 *              enough so that the full n elements may not fill into main memory)
 * Parameters:
 *      v - the original array with n elements
 *      n - the length of v
 *      k - the number of choosen elements
 * 
 * Returns:
 *      An array with k elements choosen from v
 *
 * Assert: 
 *      k <= n
 *
 * Author:  python27
 * Date:    2015/07/14
 */
vector<int> ReservoirSampling(vector<int> v, int n, int k)
{
    assert(v.size() == n && k <= n);

    // init: fill the first k elems into reservoir
    vector<int> reservoirArray(v.begin(), v.begin() + k);

    int i = 0;
    int j = 0;
    // start from the (k+1)th element to replace
    for (i = k; i < n; ++i)
    {
        j = rand() % (i + 1); // inclusive range [0, i]
        if (j < k)
        {
            reservoirArray[j] = v[i];
        }
    }

    return reservoirArray;
}


int main()
{
    vector<int> v(10, 0);
    for (int i = 0; i < 10; ++i) v[i] = i + 1;

    srand((unsigned int)time(NULL));
    // test algorithm RUN_COUNT times
    const int RUN_COUNT = 10000;
    int cnt[11] = {0};
    for (int k = 1; k <= RUN_COUNT; ++k)
    {
        cout << "Running Count " << k << endl;

        vector<int> samples = ReservoirSampling(v, 10, 5);

        for (size_t i = 0; i <samples.size(); ++i)
        {
            cout << samples[i] << " ";
            cnt[samples[i]]++;
        }
        cout << endl;
    }

    // output frequency stats
    cout << "*************************" << endl;
    cout << "Frequency Stats" << endl;
    for (int num = 1; num < 11; ++num)
    {
        cout << num << " : \t" << cnt[num] << endl;
    }
    cout << "*************************" << endl;

    return 0;
}
```



### 5.ç®—æ³•é™åˆ¶

è“„æ°´æ± ç®—æ³•çš„åŸºæœ¬å‡è®¾æ˜¯æ€»çš„æ ·æœ¬æ•°å¾ˆå¤šï¼Œä¸èƒ½æ”¾å…¥å†…å­˜ï¼Œæš—ç¤ºäº†é€‰æ‹©çš„æ ·æœ¬æ•° k æ˜¯ä¸€ä¸ªä¸ n æ— å…³çš„å¸¸æ•°ã€‚ç„¶è€Œåœ¨å®é™…çš„åº”ç”¨ä¸­ï¼Œk å¸¸å¸¸ä¸ n ç›¸å…³ï¼Œæ¯”å¦‚æˆ‘ä»¬æƒ³è¦éšæœºé€‰æ‹©1/3 çš„æ ·æœ¬ (k = n / 3)ï¼Œè¿™æ—¶å€™å°±éœ€è¦åˆ«çš„ç®—æ³•æˆ–è€…åˆ†å¸ƒå¼çš„ç®—æ³•ã€‚





