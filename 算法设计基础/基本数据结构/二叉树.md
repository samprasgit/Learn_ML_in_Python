<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [基本概念](#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
- [二叉树性质](#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 1.基本概念

#### 1.1二叉树的定义：

**二叉树**是一种特殊的树，它具有以下**特点**：
  （1）树中每个节点最多只能有两棵树，即每个节点的度最多为2。
  （2）二叉树的子树有左右之分，即**左子树**与**右子树**，次序不能颠倒。
  （3）二叉树即使只有一个子树时，也要区分是左子树还是右子树。

#### 1.2 满二叉树

**满二叉树**作为一种特殊的二叉树，它是指：所有的分支节点都存在左子树与右子树，并且所有的叶子节点都在同一层上。其**特点**有：
  （1）叶子节点只能出现在最下面一层
  （2）非叶子节点度一定是2
  （3）在同样深度的二叉树中，满二叉树的节点个数最多，节点个数为： $2^ℎ−1$，其中 ℎ为树的深度。

![img](https://images2018.cnblogs.com/blog/1238724/201806/1238724-20180606092810468-1633337399.jpg)

#### 1.3完全二叉树

若设二叉树的深度为 ℎ ，除第 ℎh 层外，其它各层 (1～ℎ−1) 的结点数都达到最大个数，第 ℎh层所有的结点都连续集中在最左边，这就是**完全二叉树**。其具有以下**特点**：
  （1）叶子节点可以出现在最后一层或倒数第二层。
  （2）最后一层的叶子节点一定集中在左部连续位置。
  （3）完全二叉树严格按层序编号。（可利用数组或列表进行实现，满二叉树同）
  （4）若一个节点为叶子节点，那么编号比其大的节点均为叶子节点。

### 2.二叉树的相关性质

#### 2.1.二叉树性质

（1）在非空二叉树的 𝑖 层上，至多有 2𝑖−1 个节点 (𝑖≥1) 。
（2）在深度为 ℎh 的二叉树上最多有 2ℎ−1个节点 （𝑘≥1) 。
（3）对于任何一棵非空的二叉树,如果叶节点个数为 𝑛0 ，度数为 2 的节点个数为 𝑛2n2 ，则有: 𝑛0=𝑛2+1

#### 2.2完全二叉树性质：



### 3.二叉树的遍历

```python
class Node():
    def __init__(self, item, lchild = None, rchild = None):
        self.item = item
        self.lchild = lchild 
        self.rchild = rchild
```



#### 3.1前序遍历

先访问根节点，再先序遍历左子树，然后再先序遍历右子树。总的来说是==**根—左—右**==

```python
def PerOrder(self, root):
    '''前序遍历'''
    if root = -None:
        return
    print(root.val, end=' ')
    self.PreOrder(root.left)
    self.PreOrder(root.right)
```

#### 3.2中序遍历

先中序访问左子树，然后访问根，最后中序访问右子树。总的来说是==左—根—右==

```python
def InOrder(self, root):
    '''中序遍历'''
    if root = None:
        return
    self.InOrder(root.left)
    print(root.val, end=' ')
    self.InOrder(root.right)
```

#### 3.3后序遍历

先后序访问左子树，然后后序访问右子树，最后访问根。总的来说是==左—右—根==

```python
def BacOrder(self, root):
    '''后序遍历'''
    if root = None:
        return
    self.BacOrder(root.left)
    self.BacOrder(root.right)
    print(root.val, end=' ')
```

#### 3.3层次遍历（广度优先遍历）BFS

利用**队列**，依次将根，左子树，右子树存入队列，按照**队列**的**先进先出**规则来实现层次遍历。



```python
def BFSP(self, root):
    '''BFS'''
    if root == None:
        return
    # queue队列保存节点
    queue = []
    queue.append(root)

    while queue:
        # 拿出队首节点
        currentNode = queue.pop(0)
        print(currentNode.val, end=' ')
        if currentNode.left:
            queue.append(currentNode.left)
        else:
            queue.append(currentNode.right)
```





#### 3.4深度优先遍历DFS

利用**栈**，先将根入栈，再将根出栈，并将根的右子树，左子树存入栈，按照**栈**的**先进后出**规则来实现深度优先遍历。

```python
def DFS(self, root):
    '''深度优先'''
    if root == None:
        return
    # 栈保存未访问过的结点
    stack = []
    stack.append(root)

    while stack:
        # 拿出栈顶元素
        currentNode = stack.pop()
        print(currentNode.val, end=' ')
        if currentNode.right:
            stack.append(currentNode.right)
        else:
            stack.append(currentNode.left)
```

